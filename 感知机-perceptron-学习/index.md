# 感知机(Perceptron)学习笔记


## 简介
### 前言
感知机是由美国学者Frank Rosenblatt在1957年提出来的，是神经网络和支持向量机的基础。


### 感知机模型
感知机是什么？
感知机接收多个输入信号，输出一个信号。
和电流向前传输一样，不过感知机的信号只有“流/不流”（1/0）两种取值。这里，0对应“不传递信号”，1对应“传递信号”。



![图1 接收两个输入信号的感知机](https://image.geoer.cn/20220701143919.png)
对感知机模型进行拆解：
1.输入部分
2.权重(就是w向量)
3.偏置
5.加权
6.输出

### 感知机原理

![图1](https://image.geoer.cn/20220701144031.png)
如上图1是一个接收两个输入信号的感知机的例子。x1、x2是输入信号，
y是输出信号，w1、w2是权重（w是weight的首字母）。图中的○称为“神
经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重$(\omega_1x_1、\omega_1x_1)$
神经元会计算传送过来的信号的总和，只有当这个总和超过了某个界限值时，才会输出1。这也称为“神经元被激活”。
这里将这个界限值称为阈值，用符号θ表示。

**以上就是感知机的原理，用数学式1表示如下：**
  
$$
y = 
\begin{cases}
0 & \omega_1x_1 + \omega_2x_2 \le \theta \\
1 & \omega_1x_1 + \omega_2x_2 > \theta
\end{cases}
$$



感知机的多个输入信号都有各自固有的权重，这些权重发挥着控制各个
信号的重要性的作用。也就是说，权重越大，对应该权重的信号的重要性就越高。




## 简单逻辑电路
### 与门(AND gate)
与门是有两个输入和一个输出的门电路，与门仅在两个输入均为1时输出1，其他时候则输出0，如下图（就跟我们学习C语言时候的与或非是一样的）
![图2 与门的真值表](https://image.geoer.cn/20220701151855.png)

下面考虑用感知机来表示这个与门
实际上，满足图2的条件的参数的选择方法有无数多个。比如，当(w1, w2, θ) = (0.5, 0.5, 0.7) 时，可以满足图 2的条件。此外，当 (w1, w2, θ) 为(0.5, 0.5, 0.8)或者(1.0, 1.0, 1.0)时，同样也满足与门的条件。设定这样的
参数后，仅当x1和x2同时为1时，信号的加权总和才会超过给定的阈值θ。



### 与非门(NAND gate) 
NAND是Not AND的意思，与非门就是颠倒了与门的输出。用真值表表示的话，如下图，仅当x1和x2同时为1时输出0，其他时候则输出1：
![图3 与非门的真值表](https://image.geoer.cn/20220701152140.png)
要表示与非门，可以用(w1, w2, θ) = (−0.5, −0.5, −0.7)这样的组合（其他的组合也是无限存在的）。实际上，只要把实现与门的参数值的符号取反，就可以实现与非门。


### 或门
或门是“只要有一个输入信号是1，输出就为1”的逻辑电路。
![图4 或门的真值表](https://image.geoer.cn/20220701152448.png)

那么我们来思考一下，应该为这个或门设定什么样的参数呢？

根据上述，我们可以知道：与门、与非门、或门的感知机构造是一样的。
实际上，3个门电路只有参数的值（权重和阈值）不同。也就是说，相同构造的感知机，只需通过适当地调整参数的值，就可以像“变色龙演员”表演不同的角色一样，变身为与门、与非门、或门。



## 感知机的实现
### 简单的实现
我们先来简单实现上述的逻辑电路。
我们先定义一个接收参数x1和x2的AND函数:
```python
# 与门
def AND(x1, x2):
    w1, w2, theta = 0.5, 0.5, 0.7
    tmp = x1*w1 + x2*w2
    if tmp <= theta:
        return 0
    elif tmp > theta:
        return 1

```
在函数内初始化$\omega_1、\omega_2、\theta$，当输入的加权总和超过阈值时返回1，否则返回0。

以上我们就实现了`与门`，同理我们也可以实现非门和或门



### 使用权重和偏置的实现
刚才的与门的实现比较直接、容易理解，但是考虑到以后的事情，我们将其修改为另外一种实现形式。在此之前，首先把式1的θ换成−b，于是就可以用式2来表示感知机的行为。

$$
y = 
\begin{cases}
0 & b + \omega_1x_1 + \omega_2x_2 \le \theta \\
1 & b + \omega_1x_1 + \omega_2x_2 > \theta
\end{cases}
$$  
此处，b称为偏置，w1和w2称为权重。
感知机会计算输入信号和权重的乘积，然后加上偏置，如果这个值大于0则输出1，否则输出0



**使用权重和偏置，可以像下面这样实现与门：**
```python
def AND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7
    tmp = np.sum(w*x) + b # w*x是相同位置各个元素分别相乘，np.sum(w*x)再计算相乘后的各个元素的总和，最后再把偏置加到这个加权总和上
    if tmp <= 0:
        return 0
    else:
        return 1
```
在这里，w1和w2是控制输入信号的重要性的参数，而偏置是调整神经元被激活的容易程度（输出信号为1的程度）的参数。
比如，若b为 −0.1，则只要输入信号的加权总和超过0.1，神经元就会被激活。但是如果b 为−20.0，则输入信号的加权总和必须超过20.0，神经元才会被激活。像这样，偏置的值决定了神经元被激活的容易程度。另外，这里我们将w1和w2称为权重，将b称为偏置，但是根据上下文，有时也会将b、w1、w2这些参数统称为权重。



实现与非门：
```python
def NAND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5])  # 仅权重和偏置与AND不同！
    b = 0.7
    tmp = np.sum(w * x) + b
    if tmp <= 0:
        return 0
    else:
        return 1
```


实现或门：
```python
def OR(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])  # 仅权重和偏置与AND不同！
    b = -0.2
    tmp = np.sum(w * x) + b
    if tmp <= 0:
        return 0
    else:
        return 1

```





## 感知机的局限
### **异或门：**
异或门也被称为逻辑异或电路。如下图所示，仅当x1或x2中的一方为1时，才会输出1（“异或”是拒绝其他的意思）。那么，要用感知机实现这个异或门的话，应该设定什么样的权重参数呢？
![](https://image.geoer.cn/20220701154922.png)

实际上，用前面介绍的感知机是无法实现这个异或门的。Why?
首先，我们试着将或门的动作形象化。或门的情况下，当权重参数(b, w1, w2) = (−0.5, 1.0, 1.0)时，可满足上图的真值表条件。此时，感知机可用下面的式子表示。

$$
y = 
\begin{cases}
0 & -0.5 + x_1 + x_2 \le 0 \\
1 & -0.5 + x_1 + x_2 > 0
\end{cases}
$$  
上面表示的感知机会生成由直线−0.5 + x1 + x2 = 0分割开的两个空
间。其中一个空间输出1，另一个空间输出0，如图：
![](https://image.geoer.cn/20220701155236.png)
  
或门在(x1, x2) = (0, 0)时输出0，在(x1, x2)为(0, 1)、(1, 0)、(1, 1)时输出1。上图中，○表示0，△表示1。如果想制作或门，需要用直线将图中的○和△分开。实际上，刚才的那条直线就将这4个点正确地分开了。  
那么，换成异或门的话会如何呢？能否像或门那样，用一条直线作出分
割图2-7中的○和△的空间呢？
想要用一条直线将图2-7中的○和△分开，无论如何都做不到。事实上，用一条直线是无法将○和△分开的。
![](https://image.geoer.cn/20220701155402.png)


### 线性/非线性
上图的○和△无法用一条直线分开，但是如果将“直线”这个限制条件去掉，就可以实现了。比如，我们可以像上上个图那样，作出分开○和△的空间。
感知机的局限性就在于它只能表示由一条直线分割的空间。上图这样弯曲的曲线无法用感知机表示。另外，由上图这样的曲线分割而成的空间称为
**非线性空间**，由直线分割而成的空间称为**线性空间**。
![](https://image.geoer.cn/20220701160008.png)



## 多层感知机
感知机不能表示异或门让人深感遗憾，但也无需悲观。实际上，感知机的绝妙之处在于它可以“叠加层”（通过叠加层来表示异或门是本节的要点）


### 已有电路的组合
异或门的制作方法有很多，其中之一就是组合我们前面做好的与门、与非门、或门进行配置。这里，与门、与非门、或门用下图中的符号表示。
另外，下图中与非门前端的○表示反转输出的意思
![](https://image.geoer.cn/20220701160343.png)


那么，思考一下，要实现异或门的话，需要如何配置与门、与非门和或门呢？
![](https://image.geoer.cn/20220701160526.png)

这里，x1和x2表示输入信号，y表示输出信号。x1和x2是与非门和或门的输入，而与非门和或门的输出则是与门的输入。
  
我们来测试一下上图是否真正实现了异或门：
这里，把s1作为与非门的输出，把s2作为或门的输出，填入真值表中。结果如下图所示，观察x1、x2、y，可以发现确实符合异或门的输出。
![](https://image.geoer.cn/20220701160653.png)




### 异或门的实现
下面我们使用Python实现上图所示的异或门(使用之前定义的函数)：

```python
def XOR(x1, x2):
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    y = AND(s1, s2)
    return y

```

下面我们试着用感知机的表示方法（明确地显示神经元）来表示这个异或门，如下图所示，异或门是一种多层结构的神经网络。这里，将最左边的一列称为第0层，中间的一列称为第1层，最右边的一列称为第2层。
叠加了多层的感知机也称为**多层感知机（multi-layered perceptron）**。

![](https://image.geoer.cn/20220701160941.png)

上图所示的2层感知机中，先在第0层和第1层的神经元之间进行信号的传送和接收，然后在第1层和第2层之间进行信号的传送和接收，具体如下所示。
1. 第0层的两个神经元接收输入信号，并将信号发送至第1层的神经元。
2. 第1层的神经元将信号发送至第2层的神经元，第2层的神经元输出y。


通过这样的结构（2层结构），感知机得以实现异或门。这可以解释为“单层感知机无法表示的东西，通过增加一层就可以解决”。也就是说，通过叠加层（加深层），感知机能进行更加灵活的表示。



> 多层感知机（在理论上）可以表示计算机





---

> 作者: [剑胆琴心](http://shuai06.github.io)  
> URL: https://shuai06.github.io/%E6%84%9F%E7%9F%A5%E6%9C%BA-perceptron-%E5%AD%A6%E4%B9%A0/  

