# 卷积神经网络(CNN)学习

<script type="text/javascript" src="/js/src/bai.js"></script>


## 前言
卷积神经网络（Convolutional Neural Network，CNN) 是多层感知机(MLP)的变种，是一类包含卷积计算且具有深度结构的前馈神经网络(FNN)，是深度学习的代表算法之一。常被用于图像识别、语音识别等各种场合，在图像识别的比赛中，基于深度学习的方法几乎都以CNN为基础。
  

CNN本质上是一个多层感知机，xx其成功的原因关键在于它所采用的局部连接和共享权值的方式xx，一方面减少了的权值的数量使得网络易于优化，另一方面降低了过拟合的风险。



## 整体结构
一般情况下，CNN的结构形式是：输入层--> Conv层 --> Pooling层 --> (重复Conv、Pooling层) … --> FC(Full-connected)层 --> 输出结果
通常输入层大小一般为2的整数倍，通常卷积层使用较小的filter，如3x3，最大也就5x5。Pooling层用于对卷积结果进行降低维度，例如选择2x2的区域对卷积层进行降低维度，则选择2x2区域的最大值作为输出，这样卷积层的维度就降为之前一半。



卷积神经网络整体架构： 卷积神经网络是一种多层的监督学习神经网络，隐含层的xx卷积层xx和xx池化层xx是实现卷积神经网络特征提取功能的核心模块。
该网络模型通过采用梯度下降法最小化损失函数对网络中的权重参数逐层反向调节，通过频繁的迭代训练提高网络的精度。
卷积神经网络的低隐层是由卷积层和最大池采样层交替组成，高层是全连接层对应传统多层感知器的隐含层和逻辑回归分类器。第一个全连接层的输入是由卷积层和子采样层进行特征提取得到的特征图像。最后一层输出层是一个分类器，可以采用逻辑回归，Softmax回归甚至是支持向量机对输入图像进行分类。

xx卷积神经网络结构包括：xx卷积层，降采样层，全链接层。每一层有多个特征图(feature map)，每个特征图通过一种卷积滤波器(filter)提取输入的一种特征，每个特征图有多个神经元。

输入图像统计和滤波器进行卷积之后，提取该局部特征，一旦该局部特征被提取出来之后，它与其他特征的位置关系也随之确定下来了，每个神经元的输入和前一层的局部感受野相连，每个特征提取层都紧跟一个用来求局部平均与二次提取的计算层，也叫特征映射层，网络的每个计算层由多个特征映射平面组成，平面上所有的神经元的权重相等。

通常将输入层到隐藏层的映射称为一个特征映射，也就是通过卷积层得到特征提取层，经过pooling之后得到特征映射层。


比如之前用Affine层实现了全连接层，一个5层的全连接的神经网络如下图的网络结构来实现：
![](http://image.xpshuai.cn/20220729202558.png)

而CNN 中新增了Convolution层和Pooling层。CNN的层的连接顺序是`Convolution - ReLU -(Pooling)`（Pooling层有时会被省
略）。这可以理解为之前的`Affine - ReLU`连接被替换成了`Convolution - 
ReLU -（Pooling）`连接。
![](http://image.xpshuai.cn/20220729202801.png)



xx卷积神经网络相比一般神经网络在图像中的优点：xx
- 网络结构能够较好的适应图像的结构
- 同时进行特征提取和分类，使得特征提取有助于特征分类
- 权值共享可以减少网络的训练参数，使得神经网络结构变得简单，适应性更强


xx在CNN中，权值更新是基于反向传播算法。xx



xx训练算法主要包括四步，这四步被分为两个阶段：xx
- 第一阶段，向前传播阶段：
- (1). 从样本集中取一个样本，输入网络；
- (2). 计算相应的实际输出；在此阶段，信息从输入层经过逐级的变换，传送到输出层。这个过程也是网络在完成训练后正常执行时执行的过程。
- 第二阶段，向后传播阶段：
- (1). 计算实际输出与相应的理想输出的差；
- (2). 按极小化误差的方法调整权矩阵。
这两个阶段的工作一般应受到精度要求的控制。

![](http://image.xpshuai.cn/20220729223317.png)





## 局部感受（稀疏连接） & 权值共享
卷积神经网络的核心思想就是局部感受野、是权值共享和pooling层，以此来达到简化网络参数并使得网络具有一定程度的位移、尺度、缩放、非线性形变稳定性。
- 局部感受野：由于图像的空间联系是局部的，每个神经元不需要对全部的图像做感受，只需要感受局部特征即可，然后在更高层将这些感受得到的不同的局部神经元综合起来就可以得到全局的信息了，这样可以减少连接的数目
- 权值共享：不同神经元之间的参数共享可以减少需要求解的参数，使用多种滤波器去卷积图像就会得到多种特征映射。权值共享其实就是对图像用同样的卷积核进行卷积操作，也就意味着第一个隐藏层的所有神经元所能检测到处于图像不同位置的完全相同的特征。其主要的能力就能检测到不同位置的同一类型特征，也就是卷积网络能很好的适应图像的小范围的平移性，即有较好的平移不变性（比如将输入图像的猫的位置移动之后，同样能够检测到猫的图像



## 卷积层、下采样层(池化层)、全连接层概览
- xx卷积层：xx通过卷积运算我们可以提取出图像的特征，通过卷积运算可以使得原始信号的某些特征增强，并且降低噪声。
- xx下采样层(池化层)：xx因为对图像进行下采样，可以减少数据处理量同时保留有用信息，采样可以混淆特征的具体位置，因为某个特征找出来之后，它的位置已经不重要了，我们只需要这个特征和其他特征的相对位置，可以应对形变和扭曲带来的同类物体的变化。
全连接层：采用softmax全连接，得到的激活值即卷积神经网络提取到的图片特征。
- xx全连接层xx：采用softmax全连接，得到的激活值即卷积神经网络提取到的图片特征。





## 卷积层
> 相当于特征提取
卷积神经网路中每层卷积层由若干卷积单元组成，每个卷积单元的参数都是通过反向传播算法优化得到的。卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网络能从低级特征中迭代提取更复杂的特征。

CNN中每一层的由多个map组成，每个map由多个神经单元组成，同一个map的所有神经单元共用一个卷积核（即权重），卷积核往往代表一个特征


### 全连接层存在的问题
在全连接层中，相邻层的神经元全部连接在一起，输出的数量可以任意决定。
xx全连接层存在什么问题呢？xx那就是数据的形状被“忽视”了。
比如，输入数据是图像时，图像通常是高、长、通道方向上的3维形状。但是，向全连接层输入时，需要将3维数据拉平为1维数据。
图像是3维形状，这个形状中应该含有重要的空间信息。比如，空间上邻近的像素为相似的值、RBG的各个通道之间分别有密切的关联性、相距较远的像素之间没有什么关联等，3维形状中可能隐藏有值得提取的本质模式。但是，因为全连接层会忽视形状，将全部的输入数据作为相同的神经元（同一维度的神经元）处理，所以无法利用与形状相关的信息。
xx而卷积层可以保持形状不变。xx当输入数据是图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此，在CNN中，可以（有可能）正确理解图像等具有形状的数据。
CNN中，有时将卷积层的输入输出数据称为特征图（feature map）


### 卷积运算
> 卷积层进行的处理就是卷积运算。卷积运算相当于图像处理中的“滤波器运算”



边缘检测包括垂直检测和水平检测：
![](http://image.xpshuai.cn/20220729204217.png)
以垂直边缘检测为例：
对一个6x6的灰度图像做卷积运算(卷积符号是`x`),即6x6x1

在神经网络卷积过程中，可以建立一个3x3的矩阵(即filter或者kernel)，如下图，那么就可以用这个filter去求它的卷积，最终输出会是一个右边4x4的图像。
把3x3的filter贴到第一张图像矩阵上，对应位置数字相乘，最后求和(xx乘积累加运算xx，如在第一位置上的值为-5),把求和值写到输出图像对应第一个位置上
![](http://image.xpshuai.cn/20220729205212.png)


然后依次移动计算第二个元素，进行相同的运算，求出对应第2个第三个位置的值：
![](http://image.xpshuai.cn/20220729205353.png)


继续移动到下一行进行计算：
![](http://image.xpshuai.cn/20220729205418.png)


直到计算出所有结果：
![](http://image.xpshuai.cn/20220729205510.png)

上述垂直检测的步骤在课后习题中，使用的是`conv_forward`函数来实现，在tensflow使用的是`tf.conv2d`,......


当然检测水平边缘也是类似的：
![](http://image.xpshuai.cn/20220729210348.png)


xx3x3的filter中填充的数字的值到底为多少仍有争议xx：
![](http://image.xpshuai.cn/20220729210709.png)
有不同的filter


> 用fxf的filter来卷积nxn的的图像，得到的新图像的维度是(n-f+1)x(n-f+1)

维度公式：
![](http://image.xpshuai.cn/20220729210858.png)


xx偏置：xx
不仅在FCN中，在CNN中除了权重参数(filter中的参数就对应之前的权重)，也存在偏置项
如下图，向应用了滤波器的数据加上了偏置。偏置通常只有1个(1x1)，这个值
会被加到应用了滤波器的所有元素上(广播机制)。
![](http://image.xpshuai.cn/20220729215915.png)






### Padding(填充)
> 使用填充主要是为了调整输出的大小
xx前面卷积操作的缺点：xx
● 每次卷积操作，图像都会变小
● 图片边缘的像素只会在输出时使用一次，丢失许多图片边界上的信息
xx解决办法：xx
卷积操作前，填充(pad)图片，比如用1个像素添加额外边缘，这样图片就变成了8x8，这样output的图片就是6x6(保持了原始尺寸)，同时也减轻图片边缘被忽略的程度
![](http://image.xpshuai.cn/20220729211049.png)

> 添加pandding后，尺寸 用fxf的filter来卷积nxn的的图像，填充宽度为p，得到的新图像的维度是(n+2p-f+1)x(n+2p-f+1)


xx到底需要填充多少宽度呢？xx
有两种卷积：
- valid卷积-->填充p宽度为0(即不填充，输出尺寸同前面)
- same卷积-->有足够的填充
![](http://image.xpshuai.cn/20220729211243.png)

filter的尺寸f取值通常是奇数（如果是偶数可能会不对称）


### Stride(卷积步长)

![](http://image.xpshuai.cn/20220729211454.png)
![](http://image.xpshuai.cn/20220729211623.png)

综上，增大步幅后，输出大小会变小。而增大填充后，输出大小会变大。

xx最终维度总结：xx
用`fxf`的filter对`nxn`图像进行卷积，步长设为`s`，padding值设置为`p`，最终得到的维度为：$\frac{n+2p-f}{s}+1$ x $\frac{n+2p-f}{s}+1$


我们尝试用上述维度公式做几个计算：
1.输入大小：(28, 31)；填充：2；步幅：3；滤波器大小：(5, 5)
![](http://image.xpshuai.cn/20220729220354.png)

2.
![](http://image.xpshuai.cn/20220729220413.png)

当除不尽的时候，一般使用`floor`向下取整


补充：交叉相关(cross correlation)
![](http://image.xpshuai.cn/20220729212215.png)
我们前面的操作没有对filter进行翻转，实际上只能称为交叉相关，并不能称为数学意义上卷积(进行翻转的才叫卷积)，但由于深度学习的约定，所以我们都称之为卷积。



### 三维卷积
和二维的卷积是类似的，通道方向上有多个特征图时，会按通道
进行输入数据和滤波器的卷积运算，并将结果相加，从而得到输出。


对于多通道的RGB图像如图(6x6x3),使用3x3的filter(3x3x3)，注意filter的通道数量必须和前面图片中的通道数相匹配。

设置为filter为3维是为了简化3x3x3的filter的运算，而不能理解为矩阵的叠加。
filter分别与图像的RGB通道对应的数字相乘,最后得到的也是二维的输出，如下图：
![](http://image.xpshuai.cn/20220729214817.png)

然后移动到下一个位置，继续做27个(3x3x3)次相乘并求和
![](http://image.xpshuai.cn/20220729214908.png)


> Note：根据想在哪个颜色上检测边缘，来决定在第几层通道设置上值，而另外的通道设置为0

![](http://image.xpshuai.cn/20220729215035.png)



xx维度公式总结：xx
$n \times n \times c_n$的图片
$f \times f \times c_f$的过滤器
会得到一个`(n-f+1, n-f+1, filter_num)`的输出



### 一个&多个卷积核
#### 一个卷积核
![](http://image.xpshuai.cn/20220729222402.png)



#### 两个(多个)卷积核
![](http://image.xpshuai.cn/20220729222449.png)



### 构建卷积网络的一层
![](http://image.xpshuai.cn/20220729221305.png)
![](http://image.xpshuai.cn/20220729221342.png)

![](http://image.xpshuai.cn/20220729221410.png)


课后习题用到的符号的总结：
![](http://image.xpshuai.cn/20220729221234.png)


层的类型：
● 卷积层(CONN)
● 池化层(POOL)
● 全连接(FC)



### 结合方块思考
来自鱼书，可能和文中其他地方维度书写顺序不一致
![](http://image.xpshuai.cn/20220729220837.png)
![](http://image.xpshuai.cn/20220729221002.png)
![](http://image.xpshuai.cn/20220729221035.png)



## 池化层(Plloing Layer)
> 相当于降维压缩数据(缩小高、常方向上的空间的运算)

池化层通常接在卷积层后面，引入它的目的就是为了简化卷积层的输出。
通俗地理解，池化层也在卷积层上架了一个窗口，但这个窗口比卷积层的窗口简单许多，不需要w，b这些参数，它只是对窗口范围内的神经元做简单的操作，如求和，求最大值，把求得的值作为池化层神经元的输入值



### Max Pooling(最大池化)
> 常用，效果也比较好
![](http://image.xpshuai.cn/20220729221642.png)

**机制：**
max pooling做的是，如果在滤波器中任何地方检测到了这些特征，就保留最大的数值，如果没有检测到，可能左侧上方四分之一区域就没有这个特征，于是那些数值的最大值仍然相当小

**特性：**
- 有超参数，但是没有需要学习的参数
- 通道数不发生变化
- 对微小的位置变化具有鲁棒性



### Average Pooling(平均池化)
![](http://image.xpshuai.cn/20220729221518.png)


Pooling的总结：
![20220729221537](http://image.xpshuai.cn/20220729221537.png)





## 为什么使用卷积？
![](http://image.xpshuai.cn/20220729222113.png)


**使用卷积网络的两个原因：**
![](http://image.xpshuai.cn/20220729222202.png)





## 经典CNN模型
- LeNet-5
- AlexNet
- VGG


### LeNet-5
> 这篇paper比较难，可以先不读
> 卷积网络的“鼻祖” —— LeNet

从一个32x32x1的灰度图像中识别手写数字为例子，
当时还不用填充，所以卷积之后尺寸都会减小

![](http://image.xpshuai.cn/20220729231429.png)

![](http://image.xpshuai.cn/20220729231524.png)


见另一文章：

### AlexNet
> 这篇paper容易看懂，建议读一读

![](http://image.xpshuai.cn/20220730100445.png)
![](http://image.xpshuai.cn/20220730101056.png)

从227x227x3的图像开始，第一层用一组96个11x11的步长为4的filter，然后图像缩小到55x55，随后的最大池化层用了3x3的filter，步长为2，降到27x27x96，然后用5x5的same卷积填充，得到27x27x256，再次做最大池化得到13x13x256，然后用3x3的same卷积填充，得到13x13x384，再次用3x3的same卷积填充，再次用3x3的same卷积填充，然后用最大池化，结果降到6x6x256=9216，所以展开为9216分结点，然后有基层全连接层，最后用sofamax输出结果。

**AlexNet采用了ReLU激活函数，data augmentation和dropout等训练技巧，为后续深度神经网络的构建提供了范本，之后的卷积神经网络都是遵循AlexNet的构建思路**


https://www.cnblogs.com/wangguchangqing/p/10333370.html



### VGG-16
> 这篇paper容易看懂，建议读一读

与大量超参数不同，结构更简单，更关注卷积层
优点：真正简化了神经网络结构

![](http://image.xpshuai.cn/20220730100655.png)
vgg16中的16指的是有16个带权重的层
高和宽尺寸每次(因为池化层)会按因子1减少，每次用一组卷积层时通道数会按因子2增加


VGG-19



## 残差网络(ResNets)

残差网络（Residual Networks）是一种卷积神经网络，其内部使用了**跳跃连接**，由大量的残差块组成，这缓解了深度神经网络中增加深度带来的梯度消失和梯度爆炸问题，由此可以利用残差网络训练很深很深的网络。

https://blog.csdn.net/qq_30093417/article/details/121108090


### 残差(residual)
“残差在数理统计中是指实际观察值与估计值（拟合值）之间的差。”
“如果回归模型正确的话， 我们可以将残差看作误差的观测值。”
![](http://image.xpshuai.cn/20220730103517.png)





### 残差块（Residual block）
把某层的输入跳跃连接到下一层乃至更深层的激活层之前，同本层输出一起经过激活函数输出。
即ResNet无需遵循主路径，可以通过快捷路径(跳过n层)进入更深的网络：
![](http://image.xpshuai.cn/20220730102535.png)
![](http://image.xpshuai.cn/20220730102551.png)
![](http://image.xpshuai.cn/20220730102941.png)

**普通网络：**
![](http://image.xpshuai.cn/20220730102657.png)


**残差网络：**
所训练网络越深，训练误差越小。下图的残差网络由五个残差块组成，该残差网络只跳跃了一层，还可跳跃多层
![](http://image.xpshuai.cn/20220730102737.png)


举例：
![](http://image.xpshuai.cn/20220730103714.png)


残差网络可以不是卷积神经网络，用全连接层也可以。当然，残差网络在被提出的论文中是用来处理图像识别问题。



### 为什么残差网络会生效
残差网络解决网络退化的原理:
如果某层网络冗余，我们希望该层能够学习到一个恒等映射函数也就是h(x)=x，但是学习这样的函数很困难，但学习F(x)=0要更简单，所以通过跳跃连接可以实现h(x)=F(x)+x的学习。

残差网络解决梯度消失的原理:
多个Resnet Blocks累积起来能解决梯度消失问题。
Resnet Block = main path + skip connection



### ResNet50
ResNet50由两个基本的块构成：`Conv Block`和`Identity Block`。
- Conv Block：跳跃连接上有卷积操作，输入和输出维度不一样，改变图片的大小和通道数，不能串联，用于改变网络维度。
- Identity Block：跳跃连接上没有卷积操作，输入和输出维度一样，不改变通道数，能串联，用于加深网络。

ResNet的各种网络结构图:
![](http://image.xpshuai.cn/20220730131358.png)
重点说明一下ResNet-50，可以看到上图中所示，ResNet-50经过了4个Block，每一个Block中分别有3，4，6，3个Bottleneck，另外网络最开始有一个卷积层，所以:3+4+6+3 * 3 + 1 = 49，加上取样层。




## 初始网络

### 1x1卷积核(网中网)
当1*1卷积出现时，在大多数情况下它作用是升/降特征的维度，这里的维度指的是通道数（厚度），而不改变图片的宽和高。

例子：
过滤器为1×1，这里是filter的数字是2，输入一张6×6×1的图片，然后对它做卷积，过滤器大小为1×1×1，结果相当于把这个图片乘以数字2，所以前三个单元格分别是2、4、6等等。用1×1的过滤器进行卷积，似乎用处不大，只是对输入矩阵乘以某个数字。但这仅仅是对于6×6×1的一个通道图片来说，1×1卷积效果不佳。
![](http://image.xpshuai.cn/20220730115347.png)

如果是一张6×6×32的图片，那么使用1×1过滤器进行卷积效果更好。具体来说，1×1卷积所实现的功能是遍历这36个单元格，计算左图中32个数字和过滤器中32个数字的元素积之和，然后应用ReLU非线性函数。
![](http://image.xpshuai.cn/20220730115617.png)

我们以其中一个单元为例，它是这个输入层上的某个切片，用这36个数字乘以这个输入层上1×1切片，得到一个实数，像这样把它画在输出中。

这个1×1×32过滤器中的32个数字可以这样理解，一个神经元的输入是32个数字（输入图片中左下角位置32个通道中的数字），即相同高度和宽度上某一切片上的32个数字，这32个数字具有不同通道，乘以32个权重（将过滤器中的32个数理解为权重），然后应用ReLU非线性函数，在这里输出相应的结果。
![](http://image.xpshuai.cn/20220730115722.png)
一般来说，如果过滤器不止一个，而是多个，就好像有多个输入单元，其输入内容为一个切片上所有数字，输出结果是6×6过滤器数量。
![](http://image.xpshuai.cn/20220730115843.png)
所以**1×1卷积可以从根本上理解为对这32个不同的位置都应用一个全连接层**，全连接层的作用是输入32个数字（过滤器数量标记为，在这36个单元上重复此过程）,输出结果是6×6×#filters（过滤器数量），以便在输入层上实施一个非平凡（non-trivial）计算。
![](http://image.xpshuai.cn/20220730115916.png)
这种方法**通常称为1×1卷积，有时也被称为Network in Network**



**再举个例子：**
假设下图左侧这是一个28×28×192的输入层，你可以使用池化层压缩它的高度和宽度，这个过程我们很清楚。但如果通道数量很大，该如何把它压缩为28×28×32维度的层呢？你可以用32个大小为1×1的过滤器，严格来讲每个过滤器大小都是1×1×192维，因为过滤器中通道数量必须与输入层中通道的数量保持一致。但是你使用了32个过滤器，输出层为28×28×32，这就是压缩通道数（）的方法，对于池化层我只是压缩了这些层的高度和宽度。
![](http://image.xpshuai.cn/20220730120142.png)

在之后我们看到在某些网络中1×1卷积是如何压缩通道数量并减少计算的。当然如果你想保持通道数192不变，这也是可行的，1×1卷积只是添加了非线性函数，当然也可以让网络学习更复杂的函数，比如，我们再添加一层，其输入为28×28×192，输出为28×28×192。
![](http://image.xpshuai.cn/20220730130549.png)

1×1卷积层就是这样实现了一些重要功能的（doing something pretty non-trivial），它给神经网络添加了一个非线性函数，从而减少或保持输入层中的通道数量不变，当然如果你愿意，也可以增加通道数量。




#### 1x1卷积核的作用：
##### 1. 放缩通道数目
假如现在有一个64x64x128的输入，需要通过卷积之后生成一个32x32x128，那我们直接可以对这个输入坐卷积或者做池化，就可以改变输入的长和宽，因为输入和输出的通道数目都是相同的。
但是如果我们需要输出一个64x64x192。那这个时候就必须要用到1x1的卷积。因为input和filter都需要一样的通道数目，因此我们可以用32个1x1x192的filter去做卷积，卷积运算的结果就是28x28x32。如图所示：
![](http://image.xpshuai.cn/20220730110652.png)


###### 2. 减少计算成本
![](http://image.xpshuai.cn/20220730110847.png)


##### 3. 增加网络的非线性性
如果我们不用改变通道数目，也不用改变长和宽。那么1x1的卷积还有另外一个好处就是增加网络的非线性。因为从一个28x28x192->28x28x192经过一个1*1的卷积之后，使得网络可以学习到更加复杂的函数形式。这样就此增加了网络的非线性性。



对1*1卷积的一种理解是：它本质上是一个完全连接的神经网络，逐一作用于这36个位置，这个全连接网络做的事情就是接收32个数字=的输入，然后输出过滤器个数的输出值



### **迁移学习（Transfer Learning）：**
相比于从头训练权重，如果使用别人已经训练好的网络结构的权重，通常能够进展得相当快，用这个作为预训练。

如果任务只有一个很小的数据集,如图所示，我们可以完全使用它的权重，把前面的层都冻结；
![](http://image.xpshuai.cn/20220730103231.png)
要是有一个更大的训练集，如图所示，我们冻结更少的层，然后训练后面的层；
![](http://image.xpshuai.cn/20220730103248.png)
或者如图3所示，换成自己的网络结构。
![](http://image.xpshuai.cn/20220730103302.png)
最后，如果有大量数据，我们应该用这些网络和它的权重当做初始化，用它们来代替随机初始化，接着你可以用梯度下降训练，更新网络所有层的所有权重。





## MobileNet
> 是一种在低运算环境(比如手机)中也能运行的网络

MobileNet是一个轻量级卷积神经网络，它进行卷积的参数比标准卷积要少很多。
MobileNet的基本单元是深度级可分离卷积，其可以分解为两个更小的操作：depthwise convolution(深度卷积)和pointwise convolution(逐点卷积)




### 深度可分离卷积
- 深度卷积(逐通道卷积)
- 逐点卷积

这篇文章介绍的很清晰，推荐看看： https://zhuanlan.zhihu.com/p/165632315

标准卷积将每个卷积核与图片的所有输入通道分别进行卷积运算，而深度可分离卷积将一个标准卷积拆分为深度卷积和逐点卷积，**深度卷积**针对每个输入通道采用不同的卷积核，即一个卷积核对应一个输入通道，而**逐点卷积**其实就是普通的卷积，只不过其采用 1x1 的卷积核，其目的是实现不同通道间特征的融合以及通道方向上的升维或降维，从卷积的结果上看二者差别不大，但深度可分离卷积的运算量要远远低于标准卷积的运算量。





![](http://image.xpshuai.cn/20220730133720.png)
以输入特征层为 M∗N∗16，输出 32 通道为例，卷积核尺寸为 33，在标准卷积情况下计算量为 M∗N∗16∗3∗3∗32(M∗N∗4608)，而在深度可分离卷积情况下计算量（M∗N∗656）为深度卷积的计算量 M∗N∗16∗3∗3 加上逐点卷积的计算量:M∗N∗16∗1∗1*∗32[28]，可以看到计算量大大减少了，随着网络的加深，这种卷积的计算优势会更加明显。



### MobileNet架构

MobileNetV2的变化：
● 在架构中添加残差连接(有助于高效向后传播)
● 在深度卷积核逐点卷积之前添加一个扩展层（在V2中，我们将扩展层+深度卷积+投影称为区块2，并重复多次利用区块2）
![](http://image.xpshuai.cn/20220730133504.png)

![](http://image.xpshuai.cn/20220730133518.png)








## 参考
https://blog.csdn.net/qq_42363032/article/details/108180740
吴恩达深度学习课程
https://aistudio.csdn.net/62e38a7ecd38997446774cc7.html
https://www.cnblogs.com/wuliytTaotao/p/9560205.html
https://zsweety.blog.csdn.net/article/details/81985082
https://blog.csdn.net/amusi1994/article/details/81091145
https://blog.csdn.net/qq_42859149/article/details/119904365
https://blog.csdn.net/qq_30093417/article/details/121108090
















---

> 作者: [剑胆琴心](http://shuai06.github.io)  
> URL: https://shuai06.github.io/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-cnn-%E5%AD%A6%E4%B9%A0/  

